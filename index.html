<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Nature Backgammon</title>
    
    <!-- React & ReactDOM -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    
    <!-- Babel for JSX -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- FontAwesome & Google Fonts -->
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Nunito:wght@400;700&display=swap" rel="stylesheet">

    <!-- Custom Config for Tailwind -->
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        wood: {
                            100: '#f7eadd',
                            200: '#e6cea0',
                            300: '#d2b48c',
                            400: '#8b5a2b',
                            500: '#5c3a1e',
                            800: '#3e2714',
                        },
                        nature: {
                            green: '#6b8c42',
                            darkGreen: '#3a5a40',
                            cream: '#fefae0',
                        }
                    },
                    fontFamily: {
                        sans: ['Nunito', 'sans-serif'],
                    }
                }
            }
        }
    </script>

    <style>
        body { user-select: none; -webkit-user-select: none; overflow: hidden; }
        .checker { box-shadow: 2px 2px 5px rgba(0,0,0,0.4); }
        .point-triangle { clip-path: polygon(50% 0%, 0% 100%, 100% 100%); }
        .point-triangle-down { clip-path: polygon(50% 100%, 0% 0%, 100% 0%); }
        
        @keyframes bounce {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-5px); }
        }
        .animate-bounce-soft { animation: bounce 1s infinite; }
        .modal-backdrop { background-color: rgba(62, 39, 20, 0.85); }

        /* Dice Pip Layouts */
        .pip-grid { display: grid; grid-template-columns: repeat(3, 1fr); grid-template-rows: repeat(3, 1fr); gap: 2px; padding: 4px; }
        .pip { background-color: black; border-radius: 50%; width: 100%; height: 100%; }
        
        /* Animation Layer */
        .flying-checker {
            position: fixed;
            z-index: 100;
            transition: top 0.5s ease-in-out, left 0.5s ease-in-out;
            pointer-events: none;
        }

        /* Side view checker for tray */
        .checker-side {
            height: 14px;
            border-radius: 4px;
            border: 1px solid rgba(0,0,0,0.3);
            position: relative;
            box-shadow: 0 2px 1px rgba(0,0,0,0.2);
        }
        .checker-side::after {
            content: '';
            position: absolute;
            top: 2px; left: 5%; right: 5%; height: 2px;
            background: rgba(255,255,255,0.2);
            border-radius: 2px;
        }
    </style>
</head>
<body class="bg-wood-800 h-screen w-screen flex items-center justify-center font-sans text-wood-800">

    <div id="root" class="w-full h-full"></div>

    <script type="text/babel">

        // ==========================================
        // TEACHER CONFIGURATION ZONE
        // ==========================================
        const CONFIG = {
            hardMode: false, 
            computerSpeed: 1200,
            showHints: true,
            teacherMessage: "Welcome to Class 4B Backgammon! Remember: Plan ahead, protect your checkers, and be a good sport!",
            defaultDiceStyle: 'pips', // 'numbers' or 'pips'
        };

        // --- Game Logic Helpers ---
        const INITIAL_BOARD = Array(24).fill(null).map(() => ({ player: null, count: 0 }));
        
        const setupBoard = () => {
            const b = JSON.parse(JSON.stringify(INITIAL_BOARD));
            const place = (idx, player, count) => { b[idx] = { player, count }; };
            place(0, 'black', 2);
            place(5, 'white', 5);
            place(7, 'white', 3);
            place(11, 'black', 5);
            place(12, 'white', 5);
            place(16, 'black', 3);
            place(18, 'black', 5);
            place(23, 'white', 2);
            return b;
        };

        const STORAGE_KEY = 'backgammon_class_4_v3';

        // --- COMPONENTS ---

        const Die = ({ value, style }) => {
            if (style === 'numbers') {
                return (
                    <div className="w-12 h-12 bg-white text-black rounded-lg flex items-center justify-center text-2xl font-bold shadow-lg border-2 border-gray-300">
                        {value}
                    </div>
                );
            }
            const pips = [];
            const layouts = {
                1: [4], 2: [0, 8], 3: [0, 4, 8], 4: [0, 2, 6, 8], 5: [0, 2, 4, 6, 8], 6: [0, 2, 3, 5, 6, 8]
            };
            const active = layouts[value] || [];

            return (
                <div className="w-12 h-12 bg-white rounded-lg shadow-lg border-2 border-gray-300 pip-grid">
                    {[...Array(9)].map((_, i) => (
                        <div key={i} className={`flex items-center justify-center`}>
                            {active.includes(i) && <div className="pip"></div>}
                        </div>
                    ))}
                </div>
            );
        };

        const Achievement = ({ icon, title, desc, unlocked }) => (
            <div className={`flex items-center p-2 mb-2 rounded-lg border-2 ${unlocked ? 'bg-nature-cream border-nature-green text-nature-darkGreen' : 'bg-gray-200 border-gray-400 text-gray-500 opacity-60'}`}>
                <div className="text-2xl mr-3 w-10 text-center">
                    <i className={`fas ${icon}`}></i>
                </div>
                <div>
                    <div className="font-bold text-sm">{title}</div>
                    <div className="text-xs">{desc}</div>
                </div>
                {unlocked && <div className="ml-auto text-nature-green"><i className="fas fa-check-circle"></i></div>}
            </div>
        );

        const Modal = ({ title, children, onClose }) => (
            <div className="fixed inset-0 modal-backdrop z-50 flex items-center justify-center p-4">
                <div className="bg-wood-100 rounded-xl shadow-2xl max-w-2xl w-full max-h-[90vh] overflow-y-auto border-4 border-wood-400">
                    <div className="bg-wood-300 p-4 rounded-t-lg border-b-2 border-wood-400 flex justify-between items-center">
                        <h2 className="text-2xl font-bold text-wood-800">{title}</h2>
                        <button onClick={onClose} className="bg-red-500 hover:bg-red-600 text-white rounded-full w-8 h-8 flex items-center justify-center">
                            <i className="fas fa-times"></i>
                        </button>
                    </div>
                    <div className="p-6">
                        {children}
                    </div>
                </div>
            </div>
        );

        const App = () => {
            // Game State
            const [board, setBoard] = React.useState(setupBoard());
            const [turn, setTurn] = React.useState('white');
            const [dice, setDice] = React.useState([]);
            const [movesLeft, setMovesLeft] = React.useState([]);
            const [bar, setBar] = React.useState({ white: 0, black: 0 });
            const [off, setOff] = React.useState({ white: 0, black: 0 });
            const [selectedPoint, setSelectedPoint] = React.useState(null);
            const [validDestinations, setValidDestinations] = React.useState([]); 
            const [winner, setWinner] = React.useState(null);
            
            // UX State
            const [gameMode, setGameMode] = React.useState('cpu');
            const [diceStyle, setDiceStyle] = React.useState(CONFIG.defaultDiceStyle);
            const [showRules, setShowRules] = React.useState(false);
            const [showAchievements, setShowAchievements] = React.useState(false);
            const [showTutor, setShowTutor] = React.useState(true);
            const [animation, setAnimation] = React.useState(null); 
            
            // Meta State
            const [achievements, setAchievements] = React.useState({
                firstWin: false, firstHit: false, safeHouse: false, runner: false, master: false,
            });
            const [stats, setStats] = React.useState({ wins: 0, gamesPlayed: 0 });

            // --- Effects ---

            React.useEffect(() => {
                const saved = localStorage.getItem(STORAGE_KEY);
                if (saved) {
                    const parsed = JSON.parse(saved);
                    setAchievements(parsed.achievements);
                    setStats(parsed.stats);
                }
            }, []);

            React.useEffect(() => {
                // AI Logic Loop
                if (gameMode === 'cpu' && turn === 'black' && !winner && !animation) {
                    if (dice.length === 0) {
                        setTimeout(() => rollDice(), 1000);
                    } else if (movesLeft.length > 0) {
                        setTimeout(() => executeAIMove(), CONFIG.computerSpeed);
                    } else {
                        setTimeout(() => endTurn(), 1000);
                    }
                }
                
                // Auto End Turn check
                if (!winner && dice.length > 0 && movesLeft.length === 0 && !animation) {
                    if (gameMode !== 'cpu' || turn === 'white') setTimeout(endTurn, 500);
                }
            }, [turn, dice, movesLeft, gameMode, winner, animation]);


            // --- Core Logic ---

            const rollDice = () => {
                const d1 = Math.floor(Math.random() * 6) + 1;
                const d2 = Math.floor(Math.random() * 6) + 1;
                let newMoves = [d1, d2];
                if (d1 === d2) newMoves = [d1, d1, d1, d1];
                setDice([d1, d2]);
                setMovesLeft(newMoves);
            };

            const endTurn = () => {
                setSelectedPoint(null);
                setValidDestinations([]);
                setTurn(prev => prev === 'white' ? 'black' : 'white');
                setDice([]);
                setMovesLeft([]);
            };

            const unlockAchievement = (key) => {
                if (!achievements[key]) {
                    const newAch = { ...achievements, [key]: true };
                    setAchievements(newAch);
                    localStorage.setItem(STORAGE_KEY, JSON.stringify({ achievements: newAch, stats }));
                }
            };

            // --- TUTOR LOGIC ---
            const getTutorMessage = () => {
                if (winner) return winner === 'white' ? "You Won! Fantastic job!" : "Game Over. Try again!";
                if (gameMode === 'cpu' && turn === 'black') return "The Computer is thinking...";
                if (turn === 'black' && gameMode === 'local') return "Player 2 (Black) turn.";
                
                // Human Turn (White)
                if (dice.length === 0) return "It's your turn! Click 'ROLL DICE' to see how far you can move.";
                
                if (bar.white > 0) {
                    if (selectedPoint === 'bar') return "Good! Now click a green dot in the opponent's home board to enter.";
                    return "Uh oh! You have a checker on the BAR. You must click the center Bar to enter the board first.";
                }

                if (selectedPoint === null) {
                    return "Click one of your White checkers to see where it can go.";
                }

                if (validDestinations.length === 0) {
                    return "This checker has no legal moves. Try clicking a different one.";
                }

                // Analyze possible moves
                const canHit = validDestinations.some(d => d.index >= 0 && d.index <= 23 && board[d.index].player === 'black');
                if (canHit) return "Look! You can land on a Black checker to HIT it and send it to the Bar!";
                
                const canBearOff = validDestinations.some(d => d.index === -1 || d.index === 24);
                if (canBearOff) return "You can Bear Off! Click the tray on the right to score a point!";

                return "Click a Green Dot to move there. The dots show you legal moves.";
            };

            // --- Move Validation ---

            const isValidSingleStep = (currentBoard, from, to, player, currentBar, currentOff) => {
                if ((player === 'white' && to < 0) || (player === 'black' && to > 23)) {
                    const homeStart = player === 'white' ? 0 : 18;
                    const homeEnd = player === 'white' ? 5 : 23;
                    if (currentBar[player] > 0) return false;
                    let checkersOutside = 0;
                    currentBoard.forEach((pt, idx) => {
                        if (pt.player === player) {
                            if (player === 'white' && idx > 5) checkersOutside++;
                            if (player === 'black' && idx < 18) checkersOutside++;
                        }
                    });
                    if (checkersOutside > 0) return false;
                    return true;
                }
                if (to < 0 || to > 23) return false;
                const dest = currentBoard[to];
                if (dest.player && dest.player !== player && dest.count >= 2) return false;
                return true;
            };

            const calculateValidDestinations = (fromIdx, player) => {
                const dests = []; 
                const myBar = player === 'white' ? bar.white : bar.black;
                if (myBar > 0 && fromIdx !== 'bar') return; 
                
                const getTarget = (start, die) => {
                    if (player === 'white') return start === 'bar' ? 24 - die : start - die;
                    else return start === 'bar' ? die - 1 : start + die;
                };

                const queue = [{ currIdx: fromIdx, remainingDice: [...movesLeft], usedDice: [] }];
                const foundDestinations = new Map(); 

                const processQueue = () => {
                    const item = queue.shift();
                    if (!item) return;
                    const uniqueDice = [...new Set(item.remainingDice)];
                    uniqueDice.forEach(die => {
                        const target = getTarget(item.currIdx, die);
                        if (isValidSingleStep(board, item.currIdx, target, player, bar, off)) {
                            const newUsed = [...item.usedDice, die];
                            const storeIdx = (target < 0) ? -1 : (target > 23 ? 24 : target);
                            if (!foundDestinations.has(storeIdx)) {
                                foundDestinations.set(storeIdx, newUsed);
                                const dieIndex = item.remainingDice.indexOf(die);
                                const newRemaining = [...item.remainingDice];
                                newRemaining.splice(dieIndex, 1);
                                if (storeIdx >= 0 && storeIdx <= 23 && newRemaining.length > 0) {
                                    queue.push({ currIdx: storeIdx, remainingDice: newRemaining, usedDice: newUsed });
                                }
                            }
                        }
                    });
                    if (queue.length > 0) processQueue();
                };
                processQueue();
                foundDestinations.forEach((diceUsed, index) => dests.push({ index, dice: diceUsed }));
                setValidDestinations(dests);
            };

            // --- Interaction ---

            const handlePointClick = (index) => {
                if (winner || animation) return;
                if (gameMode === 'cpu' && turn === 'black') return;

                if (selectedPoint !== null) {
                    const move = validDestinations.find(d => d.index === index);
                    if (move) {
                        triggerMove(selectedPoint, index, move.dice);
                        return;
                    }
                    setSelectedPoint(null);
                    setValidDestinations([]);
                }

                const myBar = turn === 'white' ? bar.white : bar.black;
                if (myBar > 0) return; 

                if (board[index].player === turn) {
                    setSelectedPoint(index);
                    calculateValidDestinations(index, turn);
                }
            };

            const handleBarClick = () => {
                if (winner || animation) return;
                const myBar = turn === 'white' ? bar.white : bar.black;
                if (myBar > 0) {
                    setSelectedPoint('bar');
                    calculateValidDestinations('bar', turn);
                }
            };

            const handleTrayClick = () => {
                if (selectedPoint === null || animation) return;
                const move = validDestinations.find(d => d.index === -1 || d.index === 24);
                if (move) triggerMove(selectedPoint, move.index, move.dice);
            };

            // --- Animation & Move Execution ---

            const triggerMove = (from, to, diceUsed) => {
                setAnimation({
                    from: from, to: to, player: turn, diceUsed: diceUsed, 
                    onComplete: () => finalizeMove(from, to, diceUsed)
                });
            };

            const finalizeMove = (from, to, diceUsed) => {
                const newBoard = [...board];
                const player = turn;
                const opponent = player === 'white' ? 'black' : 'white';

                if (from === 'bar') {
                    setBar(prev => ({ ...prev, [player]: prev[player] - 1 }));
                } else {
                    newBoard[from].count--;
                    if (newBoard[from].count === 0) newBoard[from].player = null;
                }

                if (to >= 0 && to <= 23) {
                    if (newBoard[to].player === opponent && newBoard[to].count === 1) {
                        newBoard[to].count = 1; newBoard[to].player = player;
                        setBar(prev => ({ ...prev, [opponent]: prev[opponent] + 1 }));
                        if (player === 'white') unlockAchievement('firstHit');
                    } else {
                        newBoard[to].player = player; newBoard[to].count = (newBoard[to].count || 0) + 1;
                        if (newBoard[to].count === 2 && player === 'white') unlockAchievement('safeHouse');
                    }
                } else {
                    setOff(prev => ({ ...prev, [player]: prev[player] + 1 }));
                    if (player === 'white') unlockAchievement('runner');
                }

                setBoard(newBoard);
                setAnimation(null);
                setSelectedPoint(null);
                setValidDestinations([]);

                const newMoves = [...movesLeft];
                diceUsed.forEach(die => {
                    const idx = newMoves.indexOf(die);
                    if (idx > -1) newMoves.splice(idx, 1);
                });
                setMovesLeft(newMoves);

                const myOff = off[player] + (to < 0 || to > 23 ? 1 : 0);
                if (myOff === 15) {
                    setWinner(player);
                    if (player === 'white') {
                        unlockAchievement('firstWin');
                        if (stats.wins + 1 >= 5) unlockAchievement('master');
                        const newStats = { wins: stats.wins + 1, gamesPlayed: stats.gamesPlayed + 1 };
                        setStats(newStats);
                        localStorage.setItem(STORAGE_KEY, JSON.stringify({ achievements, stats: newStats }));
                    }
                }
            };
            
            const executeAIMove = () => {
                const possibleMoves = [];
                let sources = [];
                if (bar.black > 0) sources = ['bar'];
                else board.forEach((pt, i) => { if (pt.player === 'black') sources.push(i); });

                sources.forEach(src => {
                    const uniqueDice = [...new Set(movesLeft)];
                    uniqueDice.forEach(die => {
                        const target = src === 'bar' ? die - 1 : src + die;
                        if (isValidSingleStep(board, src, target, 'black', bar, off)) {
                            let score = 1;
                            if (target > 23) score += 100;
                            else if (board[target].player === 'white' && board[target].count === 1) score += 50;
                            else if (board[target].player === 'black' && board[target].count === 1) score += 20;
                            possibleMoves.push({ from: src, to: target > 23 ? 24 : target, dice: [die], score });
                        }
                    });
                });

                if (possibleMoves.length > 0) {
                    possibleMoves.sort((a, b) => b.score - a.score);
                    const move = CONFIG.hardMode ? possibleMoves[0] : possibleMoves[Math.floor(Math.random() * possibleMoves.length)];
                    triggerMove(move.from, move.to, move.dice);
                } else {
                    setMovesLeft([]);
                }
            };

            // --- Render Helpers ---
            const getDomId = (type, index) => {
               if (type === 'point') return `pt-${index}`;
               if (type === 'bar-white') return `pt-bar-white`;
               if (type === 'bar-black') return `pt-bar-black`;
               if (type === 'off-white') return `pt-off-white`;
               if (type === 'off-black') return `pt-off-black`;
               return null;
            }

            const renderPoint = (index, isTop) => {
                const pt = board[index];
                const isSelected = selectedPoint === index;
                const validMove = validDestinations.find(d => d.index === index);
                const isBlackTriangle = index % 2 === (isTop ? 1 : 0); 
                
                return (
                    <div id={getDomId('point', index)} key={index} onClick={() => handlePointClick(index)}
                        className={`relative flex-1 h-full flex items-end justify-center ${isTop ? 'flex-col-reverse' : 'flex-col'} cursor-pointer group`}
                    >
                        <div className={`absolute w-full h-[85%] ${isTop ? 'top-0 point-triangle' : 'bottom-0 point-triangle-down'} ${isBlackTriangle ? 'bg-wood-500' : 'bg-wood-300'} ${validMove && CONFIG.showHints ? 'opacity-80 ring-2 ring-nature-green' : 'opacity-100'}`}></div>
                        {validMove && CONFIG.showHints && (
                            <div className={`absolute left-1/2 transform -translate-x-1/2 z-20 flex flex-col items-center ${isTop ? 'top-2' : 'bottom-2'}`}>
                                <div className="w-4 h-4 bg-nature-green rounded-full animate-bounce-soft"></div>
                                {validMove.dice.length > 1 && <span className="text-[10px] font-bold text-white bg-black/50 px-1 rounded mt-1">{validMove.dice.join('+')}</span>}
                            </div>
                        )}
                        <div className={`z-10 flex ${isTop ? 'flex-col' : 'flex-col-reverse'} items-center h-full py-1`}>
                            {Array.from({ length: Math.min(pt.count, 5) }).map((_, i) => (
                                <div key={i} className={`w-8 h-8 md:w-10 md:h-10 rounded-full border-2 ${pt.player === 'white' ? 'bg-stone-100 border-stone-300' : 'bg-stone-800 border-black'} checker -my-1 shadow-md ${isSelected && i === Math.min(pt.count, 5) - 1 ? 'ring-4 ring-yellow-400' : ''}`}>
                                    {i === 4 && pt.count > 5 && <span className={`flex items-center justify-center h-full text-xs font-bold ${pt.player === 'white' ? 'text-black' : 'text-white'}`}>+{pt.count - 5}</span>}
                                </div>
                            ))}
                        </div>
                    </div>
                );
            };

            const renderOffCheckers = (player) => (
                <div id={getDomId(`off-${player}`)} className={`flex ${player === 'white' ? 'flex-col-reverse' : 'flex-col'} items-center py-2 w-full h-full ${player === 'white' ? 'justify-start' : 'justify-end'}`}>
                    {Array.from({ length: off[player] }).map((_, i) => (
                        <div key={i} className={`
                            w-10 checker-side -my-1
                            ${player === 'white' ? 'bg-stone-100' : 'bg-stone-800'}
                        `} style={{zIndex: i}}></div>
                    ))}
                </div>
            );

            // --- ANIMATION ---
            const FlyingChecker = () => {
                if (!animation) return null;
                const { from, to, player } = animation;
                let startId = from === 'bar' ? getDomId(`bar-${player}`) : getDomId('point', from);
                let endId = to === -1 ? getDomId('off-white') : to === 24 ? getDomId('off-black') : getDomId('point', to);

                const [style, setStyle] = React.useState({});
                React.useLayoutEffect(() => {
                    const startEl = document.getElementById(startId);
                    const endEl = document.getElementById(endId);
                    if (!startEl || !endEl) { animation.onComplete(); return; }
                    const sRect = startEl.getBoundingClientRect();
                    const eRect = endEl.getBoundingClientRect();
                    const startX = sRect.left + sRect.width/2 - 20; const startY = sRect.top + sRect.height/2 - 20;
                    const endX = eRect.left + eRect.width/2 - 20; const endY = eRect.top + eRect.height/2 - 20;
                    setStyle({ top: startY, left: startX });
                    requestAnimationFrame(() => setStyle({ top: endY, left: endX }));
                    const timer = setTimeout(() => animation.onComplete(), 500);
                    return () => clearTimeout(timer);
                }, []);

                return <div className={`flying-checker w-10 h-10 rounded-full border-2 shadow-xl z-50 ${player === 'white' ? 'bg-stone-100 border-stone-300' : 'bg-stone-800 border-black'}`} style={style}></div>;
            };

            const canBearOffNow = validDestinations.some(d => d.index === -1 || d.index === 24);

            return (
                <div className="flex w-full h-full max-w-[1366px] bg-wood-200 shadow-2xl overflow-hidden relative">
                    <FlyingChecker />
                    <div className="w-64 bg-wood-800 text-wood-100 p-4 flex flex-col justify-between shadow-xl z-20">
                        <div>
                            <h1 className="text-3xl font-bold mb-1 text-nature-cream font-serif"><i className="fas fa-leaf mr-2"></i>Backgammon</h1>
                            <p className="text-xs text-wood-300 mb-6">Class 4B Edition v3.0</p>
                            
                            {/* Tutor Box */}
                            {showTutor && (
                                <div className="bg-nature-cream text-wood-800 p-3 rounded-lg mb-4 text-sm border-l-4 border-nature-green shadow-lg relative animate-bounce-soft">
                                    <div className="font-bold text-nature-darkGreen mb-1"><i className="fas fa-graduation-cap mr-1"></i> Tutor</div>
                                    {getTutorMessage()}
                                    <div className="absolute -left-2 top-4 w-0 h-0 border-t-[8px] border-t-transparent border-r-[8px] border-r-nature-green border-b-[8px] border-b-transparent"></div>
                                </div>
                            )}

                            <div className="bg-wood-500 rounded-lg p-3 mb-4 text-center shadow-inner">
                                <h3 className="text-sm uppercase tracking-widest text-wood-300 mb-2">Turn</h3>
                                <div className="text-2xl font-bold flex items-center justify-center gap-2">
                                    {turn === 'white' ? <span className="text-white"><i className="fas fa-circle"></i> YOU</span> : <span className="text-black"><i className="fas fa-circle"></i> {gameMode === 'cpu' ? 'CPU' : 'P2'}</span>}
                                </div>
                                <div className="mt-2 text-sm text-wood-200">
                                    {movesLeft.length > 0 ? `Moves: ${movesLeft.join(', ')}` : "Roll to start!"}
                                </div>
                            </div>
                            <div className="flex justify-center mb-6">
                                {dice.length > 0 ? (
                                    <div className="flex gap-4">{dice.map((d, i) => <Die key={i} value={d} style={diceStyle} />)}</div>
                                ) : (
                                    <button onClick={rollDice} disabled={winner || (gameMode === 'cpu' && turn === 'black') || animation} className="bg-nature-green hover:bg-nature-darkGreen text-white font-bold py-3 px-6 rounded-full shadow-lg transform transition hover:scale-105 disabled:opacity-50 disabled:cursor-not-allowed">ROLL DICE</button>
                                )}
                            </div>
                        </div>

                        <div className="space-y-2">
                            <button onClick={() => setShowTutor(!showTutor)} className={`w-full py-1 rounded text-xs flex items-center justify-center gap-2 ${showTutor ? 'bg-nature-green text-white' : 'bg-wood-500 text-wood-300'}`}>
                                <i className="fas fa-graduation-cap"></i> {showTutor ? 'Tutor ON' : 'Tutor OFF'}
                            </button>
                            <button onClick={() => setDiceStyle(s => s === 'pips' ? 'numbers' : 'pips')} className="w-full bg-wood-500/50 hover:bg-wood-500 py-1 rounded text-xs flex items-center justify-center gap-2">
                                <i className="fas fa-dice"></i> {diceStyle === 'pips' ? 'Use Numbers' : 'Use Pips'}
                            </button>
                            <button onClick={() => setShowAchievements(true)} className="w-full bg-wood-400 hover:bg-wood-500 py-2 rounded text-sm font-bold flex items-center justify-center gap-2">
                                <i className="fas fa-trophy text-yellow-400"></i> Badges
                            </button>
                            <button onClick={() => setShowRules(true)} className="w-full bg-wood-400 hover:bg-wood-500 py-2 rounded text-sm font-bold">
                                <i className="fas fa-book mr-2"></i> How to Play
                            </button>
                            <div className="grid grid-cols-2 gap-2 mt-2">
                                <button onClick={() => window.location.reload()} className="bg-wood-500 hover:bg-wood-600 py-1 rounded text-xs">New Game</button>
                                <button onClick={() => setGameMode(prev => prev === 'cpu' ? 'local' : 'cpu')} className="bg-wood-500 hover:bg-wood-600 py-1 rounded text-xs">
                                    {gameMode === 'cpu' ? 'Vs Friend' : 'Vs CPU'}
                                </button>
                            </div>
                        </div>
                    </div>

                    <div className="flex-1 flex relative overflow-hidden">
                        <div className="flex-1 p-4 flex flex-col relative h-full">
                            <div onClick={handleBarClick} className={`absolute left-1/2 top-4 bottom-4 w-16 bg-wood-800 transform -translate-x-1/2 rounded shadow-inner flex flex-col justify-center items-center py-4 z-10 cursor-pointer ${bar[turn] > 0 ? 'ring-2 ring-red-500' : ''}`}>
                                <div id="pt-bar-white" className="flex-1 flex flex-col justify-center gap-1 w-full items-center border-b border-wood-600">
                                    {Array.from({ length: bar.white }).map((_, i) => <div key={i} className="w-8 h-8 rounded-full bg-stone-100 border-2 border-stone-300 shadow"></div>)}
                                    {bar.white > 0 && <span className="text-white font-bold text-xs">{bar.white}</span>}
                                </div>
                                <div className="text-wood-400 font-serif font-bold py-2 tracking-widest text-center text-xs">BAR</div>
                                <div id="pt-bar-black" className="flex-1 flex flex-col justify-center gap-1 w-full items-center border-t border-wood-600">
                                    {Array.from({ length: bar.black }).map((_, i) => <div key={i} className="w-8 h-8 rounded-full bg-stone-800 border-2 border-black shadow"></div>)}
                                    {bar.black > 0 && <span className="text-white font-bold text-xs">{bar.black}</span>}
                                </div>
                            </div>

                            <div className="flex-1 flex border-4 border-wood-500 rounded-t-lg bg-wood-200">
                                <div className="flex-1 flex border-r-4 border-wood-500 mr-8">{[12, 13, 14, 15, 16, 17].map(idx => renderPoint(idx, true))}</div>
                                <div className="flex-1 flex border-l-4 border-wood-500 ml-8">{[18, 19, 20, 21, 22, 23].map(idx => renderPoint(idx, true))}</div>
                            </div>
                            <div className="flex-1 flex border-4 border-t-0 border-wood-500 rounded-b-lg bg-wood-200">
                                <div className="flex-1 flex border-r-4 border-wood-500 mr-8">{[11, 10, 9, 8, 7, 6].map(idx => renderPoint(idx, false))}</div>
                                <div className="flex-1 flex border-l-4 border-wood-500 ml-8 bg-nature-cream/20">{[5, 4, 3, 2, 1, 0].map(idx => renderPoint(idx, false))}</div>
                            </div>
                            
                            {winner && (
                                <div className="absolute inset-0 z-40 bg-black/60 flex items-center justify-center">
                                    <div className="bg-wood-100 p-8 rounded-xl shadow-2xl text-center border-4 border-nature-green animate-bounce">
                                        <h2 className="text-4xl font-bold text-wood-800 mb-2">{winner === 'white' ? "YOU WON!" : "BLACK WINS!"}</h2>
                                        <button onClick={() => window.location.reload()} className="bg-nature-green text-white px-8 py-3 rounded-full font-bold shadow-lg hover:bg-nature-darkGreen">Play Again</button>
                                    </div>
                                </div>
                            )}
                        </div>

                        <div onClick={handleTrayClick} className={`w-24 bg-wood-800 border-l-4 border-wood-500 flex flex-col py-4 relative cursor-pointer transition-colors duration-300 ${canBearOffNow ? 'bg-wood-500 ring-inset ring-4 ring-nature-green/70' : ''} hover:bg-wood-500`}>
                             <div className="flex-1 flex flex-col items-center gap-1 border-b-2 border-wood-400 p-2">
                                <span className="text-wood-300 text-xs font-bold uppercase mb-2">Black Off</span>
                                {renderOffCheckers('black')}
                             </div>
                             <div className="flex-1 flex flex-col-reverse items-center gap-1 border-t-2 border-wood-400 p-2">
                                <span className="text-wood-300 text-xs font-bold uppercase mb-2">White Off</span>
                                {renderOffCheckers('white')}
                             </div>
                        </div>
                    </div>

                    {showRules && <Modal title="How to Play" onClose={() => setShowRules(false)}>
                        <div className="space-y-4 text-wood-800">
                            <div className="bg-nature-cream p-4 rounded-lg border border-wood-300 italic">"{CONFIG.teacherMessage}"</div>
                            <h3 className="font-bold text-lg border-b border-wood-400 pb-1">Combined Moves</h3>
                            <p>If you roll 5 and 4, you can move one checker 5, then 4 (total 9). The green dots will show you these long jumps automatically!</p>
                            <div className="text-center pt-4"><button onClick={() => { localStorage.removeItem(STORAGE_KEY); window.location.reload(); }} className="text-xs text-red-500 underline">Reset Saved Data</button></div>
                        </div>
                    </Modal>}

                    {showAchievements && <Modal title="Badges" onClose={() => setShowAchievements(false)}>
                        <div className="grid grid-cols-1 gap-2">
                            <Achievement icon="fa-star" title="First Win" desc="Win your first game." unlocked={achievements.firstWin} />
                            <Achievement icon="fa-bullseye" title="First Blood" desc="Hit an opponent's checker." unlocked={achievements.firstHit} />
                            <Achievement icon="fa-shield-alt" title="Safe House" desc="Make a point (stack 2)." unlocked={achievements.safeHouse} />
                            <Achievement icon="fa-running" title="Home Stretch" desc="Bear off a checker." unlocked={achievements.runner} />
                            <Achievement icon="fa-crown" title="Backgammon Master" desc="Win 5 games." unlocked={achievements.master} />
                        </div>
                    </Modal>}
                </div>
            );
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);

    </script>
</body>
</html>
